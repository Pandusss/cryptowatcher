# Объяснение полей конфига монет (coins.json)

## Структура конфига

```json
{
  "version": "1.0",
  "coins": {
    "bitcoin": {
      "id": "bitcoin",
      "name": "Bitcoin",
      "symbol": "BTC",
      "enabled": true,
      "external_ids": {
        "coingecko": "bitcoin",
        "binance": "BTCUSDT"
      },
      "price_priority": ["binance"]
    }
  }
}
```

---

## Поля верхнего уровня

### `version` (string)
**Назначение:** Версия формата конфига  
**Использование:** Для будущих миграций и проверки совместимости  
**Пример:** `"1.0"`  
**Можно упростить?** Да, можно убрать, если не планируете менять формат

---

## Поля внутри монеты

### 1. `id` (string) - **ОБЯЗАТЕЛЬНОЕ**
**Назначение:** Внутренний уникальный идентификатор монеты в системе  
**Использование:**
- Ключ в словаре `coins`
- Используется для поиска монеты: `coin_registry.get_coin("bitcoin")`
- Используется в API: `/coins/bitcoin`
- Используется в базе данных для уведомлений
- Используется в Redis кэше: `coin_price:bitcoin`

**Примеры:**
- `"bitcoin"` - для Bitcoin
- `"ethereum"` - для Ethereum
- `"0g"` - для монеты 0G

**Можно упростить?** Нет, это ключевое поле

---

### 2. `name` (string) - **ОБЯЗАТЕЛЬНОЕ**
**Назначение:** Человекочитаемое название монеты для отображения  
**Использование:**
- Отображается в списке монет на фронтенде
- Отображается в уведомлениях
- Используется в поиске (потенциально)

**Примеры:**
- `"Bitcoin"` - полное название
- `"0x Protocol"` - для ZRX
- `"1000CAT"` - для мем-коинов

**Можно упростить?** Можно, но нежелательно - используется для UI

---

### 3. `symbol` (string) - **ОБЯЗАТЕЛЬНОЕ**
**Назначение:** Торговый символ монеты (тикер)  
**Использование:**
- Отображается рядом с названием: "Bitcoin (BTC)"
- Используется для иконок: `CryptoIcon(symbol="BTC")`
- Используется в уведомлениях: "BTC вырос на 5%"

**Примеры:**
- `"BTC"` - для Bitcoin
- `"ETH"` - для Ethereum
- `"1000CAT"` - для монет с префиксом

**Можно упростить?** Нет, используется в UI

---

### 4. `enabled` (boolean) - **ОБЯЗАТЕЛЬНОЕ**
**Назначение:** Включена ли монета в систему  
**Использование:**
- Фильтрация: `coin_registry.get_all_coins(enabled_only=True)` возвращает только включенные
- Можно временно отключить монету без удаления из конфига
- Используется в `get_coins_by_source()` - только enabled монеты

**Примеры:**
- `true` - монета активна
- `false` - монета отключена (не показывается в списках)

**Можно упростить?** Можно, но полезно для управления - можно отключать проблемные монеты

---

### 5. `external_ids` (object) - **ОБЯЗАТЕЛЬНОЕ**
**Назначение:** Маппинг внутреннего ID на внешние идентификаторы разных источников  
**Использование:**
- `coin.external_ids.get("binance")` → `"BTCUSDT"` - для получения цен из Binance
- `coin.external_ids.get("coingecko")` → `"bitcoin"` - для получения статики из CoinGecko
- Используется в `AggregationService` для определения, откуда брать данные
- Используется в `BinanceWebSocketWorker` для маппинга символов

**Структура:**
```json
"external_ids": {
  "binance": "BTCUSDT",      // Символ на Binance
  "coingecko": "bitcoin",    // ID на CoinGecko
  "kucoin": "BTC-USDT"       // Можно добавить другие биржи
}
```

**Примеры использования:**
- Получение цены: `coin_registry.get_external_id("bitcoin", "binance")` → `"BTCUSDT"`
- Поиск монеты: `coin_registry.find_coin_by_external_id("binance", "BTCUSDT")` → находит Bitcoin
- Проверка доступности: `coin_registry.get_coins_by_source("binance")` → все монеты с Binance маппингом

**Можно упростить?** Нет, это ключевое поле для работы с разными источниками

---

### 6. `price_priority` (array) - **ОБЯЗАТЕЛЬНОЕ**
**Назначение:** Порядок приоритета источников для получения цен  
**Использование:**
- `AggregationService.get_coin_price()` пробует провайдеры по порядку
- Если первый провайдер недоступен, пробует следующий
- Используется для fallback механизма

**Примеры:**
```json
"price_priority": ["binance"]                    // Только Binance
"price_priority": ["binance", "kucoin"]          // Сначала Binance, потом KuCoin
"price_priority": ["kucoin", "binance"]         // Сначала KuCoin, потом Binance
```

**Как работает:**
1. Система берет первый провайдер из списка (`"binance"`)
2. Пытается получить цену через `BinancePriceAdapter`
3. Если цена получена → возвращает её
4. Если нет → пробует следующий провайдер (если есть)

**Можно упростить?** Можно сделать по умолчанию `["binance"]`, но полезно для гибкости

---

## Примеры использования в коде

### 1. Получение монеты по ID
```python
coin = coin_registry.get_coin("bitcoin")
# coin.id = "bitcoin"
# coin.name = "Bitcoin"
# coin.symbol = "BTC"
```

### 2. Получение Binance символа
```python
binance_symbol = coin_registry.get_external_id("bitcoin", "binance")
# → "BTCUSDT"
```

### 3. Поиск монеты по Binance символу
```python
coin = coin_registry.find_coin_by_external_id("binance", "BTCUSDT")
# → CoinConfig(id="bitcoin", ...)
```

### 4. Получение приоритетов цен
```python
providers = coin_registry.get_price_providers("bitcoin")
# → ["binance"]
```

### 5. Фильтрация по enabled
```python
all_coins = coin_registry.get_all_coins(enabled_only=True)
# → только монеты с enabled=true
```

### 6. Получение монет по источнику
```python
binance_coins = coin_registry.get_coins_by_source("binance")
# → все монеты, у которых есть "binance" в external_ids
```

---

## Что можно упростить?

### ✅ Можно убрать:
1. **`version`** - если не планируете менять формат
2. **`name`** - можно генерировать из `symbol` или `id` (но хуже для UI)

### ❌ Нельзя убрать:
1. **`id`** - ключевое поле для идентификации
2. **`symbol`** - используется в UI
3. **`enabled`** - полезно для управления
4. **`external_ids`** - критично для работы с источниками
5. **`price_priority`** - нужно для fallback механизма

---

## Предложение по упрощению

Если хотите упростить конфиг, можно:

1. **Убрать `version`** - не используется в коде
2. **Сделать `enabled` опциональным** - по умолчанию `true`
3. **Сделать `price_priority` опциональным** - по умолчанию `["binance"]`
4. **Упростить `name`** - использовать `symbol` или `id` как fallback

Но текущая структура довольно оптимальна и понятна.

